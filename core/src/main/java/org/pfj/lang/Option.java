/*
 * Copyright (c) 2021 Sergiy Yevtushenko.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.pfj.lang;

import org.pfj.lang.Functions.FN1;
import org.pfj.lang.Functions.FN2;
import org.pfj.lang.Functions.FN3;
import org.pfj.lang.Functions.FN4;
import org.pfj.lang.Functions.FN5;
import org.pfj.lang.Functions.FN6;
import org.pfj.lang.Functions.FN7;
import org.pfj.lang.Functions.FN8;
import org.pfj.lang.Functions.FN9;
import org.pfj.lang.Tuple.Tuple1;
import org.pfj.lang.Tuple.Tuple2;
import org.pfj.lang.Tuple.Tuple3;
import org.pfj.lang.Tuple.Tuple4;
import org.pfj.lang.Tuple.Tuple5;
import org.pfj.lang.Tuple.Tuple6;
import org.pfj.lang.Tuple.Tuple7;
import org.pfj.lang.Tuple.Tuple8;
import org.pfj.lang.Tuple.Tuple9;

import java.util.Objects;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Stream;

import static org.pfj.lang.Tuple.tuple;

/**
 * Implementation of basic immutable container for value which may or may not be present.
 *
 * @param <T> Type of contained value
 */
public interface Option<T> {
	/**
	 * Convert instance into other instance of different type using provided mapping function. Empty instance is mapped into empty
	 * instance of different type. Non-empty instance is converted to empty or present instance depending on results of execution
	 * of mapping function. Mapping function receives value contained in the current instance only if current instance is not empty.
	 * Result of invocation of mapping function is wrapped into new instance. If result of application of mapping function is
	 * <code>null</code>, then resulting instance will be empty.
	 * <p>
	 * <b>WARNING!</b> It is highly discouraged to use this method with mapping functions which may return
	 * <code>null</code>. Such a usage may result to subtle, hard to debug issues.
	 * If such a behavior is actually necessary then use of {@link #flatMap(FN1)} provides more clear and less error-prone way to
	 * achieve it.
	 *
	 * @param mapper Mapping function
	 * @param <U> Type of new value
	 *
	 * @return transformed instance
	 */
	default <U> Option<U> map(FN1<U, ? super T> mapper) {
		return flatMap(t -> option(mapper.apply(t)));
	}

	/**
	 * Replace current present instance with another one generated by applying provided mapper to value stored in this instance.
	 * Empty instance is replaced with empty instance of new type matching type of provided mapping function.
	 *
	 * @param mapper Mapping function
	 * @param <U> New type
	 *
	 * @return Instance of new type
	 */
	default <U> Option<U> flatMap(FN1<Option<U>, ? super T> mapper) {
		return reduce(Option::empty, mapper);
	}

	/**
	 * Transform instance according to results of testing of contained value with provided predicate. If instance is empty, it
	 * remains empty. If instance contains value, this value is passed to predicate. If predicate returns <code>true</code> then
	 * instance remains untouched. If predicate returns <code>false</code> then empty instance is returned instead.
	 *
	 * @param predicate Predicate to test instance value.
	 *
	 * @return current instance if it is not empty and predicate returns <code>true</code> and empty instance otherwise
	 */
	default Option<T> filter(Predicate<? super T> predicate) {
		return flatMap(v -> predicate.test(v) ? this : empty());
	}

	/**
	 * Pass internal value to provided consumer in-line. Consumer is invoked only is current instance is not empty. This is a
	 * convenience method which can be inserted at any point of fluent call chain. Note that provided consumer should not change
	 * value in any way (for example, if contained value is mutable collection/map/array/etc.) and should not throw any kind of
	 * exceptions.
	 *
	 * @param consumer Consumer to pass contained value to
	 *
	 * @return this instance for fluent call chaining
	 */
	default Option<T> whenPresent(Consumer<? super T> consumer) {
		apply(() -> {}, consumer);
		return this;
	}

	/**
	 * Execute action if instance is empty and do nothing otherwise.
	 *
	 * @param action Action to perform on empty instance
	 *
	 * @return this instance for fluent call chaining
	 */
	default Option<T> whenEmpty(Runnable action) {
		apply(action, __ -> {});
		return this;
	}

	/**
	 * Convenience method which allows to perform specific actions for empty and present instances at once.
	 *
	 * @param emptyValConsumer Action to perform in case of empty instance
	 * @param nonEmptyValConsumer Action to perform on present instance value
	 *
	 * @return this instance for fluent call chaining
	 */
	default Option<T> apply(Runnable emptyValConsumer, Consumer<? super T> nonEmptyValConsumer) {
		reduce(() -> {
			emptyValConsumer.run();
			return null;
		}, t2 -> {
			nonEmptyValConsumer.accept(t2);
			return null;
		});
		return this;
	}

	/**
	 * Return current value stored in current instance if current instance is present. If current instance is empty then return
	 * provided replacement value.
	 *
	 * @param replacement Replacement value returned in case if current instance is empty
	 *
	 * @return either value stored in current instance or provided replacement value if current instance is empty
	 */
	default T otherwise(T replacement) {
		return reduce(() -> replacement, v -> v);
	}

	/**
	 * Return current value stored in current instance if current instance is present. If current instance is empty then return
	 * value returned by provided supplier. If current instance is not empty then supplier is not invoked.
	 *
	 * @param supplier Supplier for replacement value returned in case if current instance is empty
	 *
	 * @return either value stored in current instance or value returned by provided supplier if current instance is empty
	 */
	default T otherwiseGet(Supplier<T> supplier) {
		return reduce(supplier, v -> v);
	}

	/**
	 * Logical <code>OR</code> between current instance and instance of same type provided by specified supplier. First present
	 * instance is returned. Note that if current instance is not empty then supplier is not invoked.
	 *
	 * @param supplier Supplier which provides new instance in case if current instance is empty
	 *
	 * @return first present instance, either current one or one returned by provided supplier
	 */
	default Option<T> or(Supplier<Option<T>> supplier) {
		return reduce(supplier, v -> this);
	}

	/**
	 * Logical <code>OR</code> between current instance and provided instance of same type. First present instance is returned.
	 *
	 * @param replacement Replacement instance which is returned in case if current instance is empty
	 *
	 * @return first present instance, either current one or one returned by provided supplier
	 */
	default Option<T> or(Option<T> replacement) {
		return reduce(() -> replacement, v -> this);
	}

	/**
	 * Stream current instance. For empty instance empty stream is created. For present instance the stream with single element is
	 * returned. The element is the value stored in current instance.
	 *
	 * @return created stream
	 */
	default Stream<T> stream() {
		return reduce(Stream::empty, Stream::of);
	}

	/**
	 * Convert current instance to instance of {@link Result}.
	 * The present instance is converted into success result.
	 * The empty instance is converted into failure result with provided {@link Failure}.
	 *
	 * @param failure the failure necessary for conversion of empty instance.
	 *
	 * @return created instance
	 */
	default Result<T> toResult(Failure failure) {
		return reduce(() -> Result.fail(failure), Result::ok);
	}

	/**
	 * Convert current instance to instance of {@link Result}.
	 * The present instance is converted into success result.
	 * The empty instance is converted into failure result with provided failure message.
	 *
	 * @param failure the failure message necessary for conversion of empty instance.
	 *
	 * @return created instance
	 */
	default Result<T> toResult(String failure) {
		return reduce(() -> Result.fail(failure), Result::ok);
	}

	/**
	 * Convert current instance to instance of {@link Result}.
	 * The present instance is converted into success result.
	 * The empty instance is converted into failure result with provided failure message.
	 *
	 * @param format failure message format.
	 * @param params failure message parameters.
	 *
	 * @return created instance
	 *
	 * @see java.text.MessageFormat for message format details.
	 */
	default Result<T> toResult(String format, Object... params) {
		return reduce(() -> Result.fail(format, params), Result::ok);
	}

	/**
	 * Convert current instance to instance of {@link Optional}.
	 * The present instance is converted into present instance of {@link Optional}.
	 * The empty instance is converted into empty instance of {@link Optional}.
	 *
	 * @return created instance
	 */
	default Optional<T> toOptional() {
		return reduce(Optional::empty, Optional::of);
	}

	/**
	 * Handle both possible states (empty/present) and produce single result from it.
	 *
	 * @param emptyMapper function to produce value in case of empty instance
	 * @param presentMapper function to transform present value into output value
	 *
	 * @return result of application of one of the mappers.
	 */
	<R> R reduce(Supplier<? extends R> emptyMapper, FN1<? extends R, ? super T> presentMapper);

	/**
	 * Convert nullable value into instance of {@link Option}. This method converts {@code null} to empty instance and any other
	 * value into present instance.
	 *
	 * @param value Value to convert.
	 *
	 * @return created instance.
	 */
	static <T> Option<T> option(T value) {
		return value == null ? Option.empty() : Option.present(value);
	}

	/**
	 * Create instance of {@link Option} from {@link Optional}.
	 *
	 * @param optional input optional instance.
	 *
	 * @return created instance.
	 */
	@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
	static <T> Option<T> from(Optional<T> optional) {
		return option(optional.orElse(null));
	}

	/**
	 * Create empty instance.
	 *
	 * @return Created instance
	 */
	@SuppressWarnings("unchecked")
	static <R> Option<R> empty() {
		return (Option<R>) EMPTY_OPTION;
	}

	@SuppressWarnings({"rawtypes"})
	Option EMPTY_OPTION = new Option() {
		@Override
		public Object reduce(Supplier emptyMapper, FN1 presentMapper) {
			return emptyMapper.get();
		}

		@Override
		public boolean equals(Object o) {
			return this == o;
		}

		@Override
		public int hashCode() {
			return super.hashCode();
		}

		@Override
		public String toString() {
			return "Option()";
		}
	};

	/**
	 * Create a present instance with the passed value.
	 *
	 * @param value Value to be stored in the created instance.
	 *
	 * @return Created instance
	 */
	static <R> Option<R> present(R value) {
		return new Option<>() {
			@Override
			public <T> T reduce(Supplier<? extends T> emptyMapper, FN1<? extends T, ? super R> presentMapper) {
				return presentMapper.apply(value);
			}

			@Override
			public boolean equals(Object o) {
				if (this == o) {
					return true;
				}

				if (o instanceof Option<?> option) {
					return reduce(
						() -> option.reduce(() -> true, vo -> false),
						v -> option.reduce(() -> false, vo -> Objects.equals(v, vo))
					);
				}

				return false;
			}

			@Override
			public int hashCode() {
				return Objects.hash(value);
			}

			@Override
			public String toString() {
				return "Option(" + value.toString() + ")";
			}
		};
	}

	/**
	 * Find first present option among ones passed as parameters.
	 *
	 * @return first present option or empty option if all input options are empty.
	 */
	static <T> Option<T> any(Option<T> op1, Option<T> op2) {
		return op1.or(op2);
	}

	/**
	 * Find first present option among ones passed as parameters.
	 *
	 * @return first present option or empty option if all input options are empty.
	 */
	static <T> Option<T> any(Option<T> op1, Option<T> op2, Option<T> op3) {
		return op1.or(op2).or(op3);
	}

	/**
	 * Find first present option among ones passed as parameters.
	 *
	 * @return first present option or empty option if all input options are empty.
	 */
	static <T> Option<T> any(Option<T> op1, Option<T> op2, Option<T> op3, Option<T> op4) {
		return op1.or(op2).or(op3).or(op4);
	}

	/**
	 * Find first present option among ones passed as parameters.
	 *
	 * @return first present option or empty option if all input options are empty.
	 */
	static <T> Option<T> any(Option<T> op1, Option<T> op2, Option<T> op3, Option<T> op4, Option<T> op5) {
		return op1.or(op2).or(op3).or(op4).or(op5);
	}

	/**
	 * Find first present option among ones passed as parameters.
	 *
	 * @return first present option or empty option if all input options are empty.
	 */
	static <T> Option<T> any(
		Option<T> op1, Option<T> op2, Option<T> op3, Option<T> op4, Option<T> op5, Option<T> op6
	) {
		return op1.or(op2).or(op3).or(op4).or(op5).or(op6);
	}

	/**
	 * Find first present option among ones passed as parameters.
	 *
	 * @return first present option or empty option if all input options are empty.
	 */
	static <T> Option<T> any(
		Option<T> op1, Option<T> op2, Option<T> op3, Option<T> op4, Option<T> op5, Option<T> op6, Option<T> op7
	) {
		return op1.or(op2).or(op3).or(op4).or(op5).or(op6).or(op7);
	}

	/**
	 * Find first present option among ones passed as parameters.
	 *
	 * @return first present option or empty option if all input options are empty.
	 */
	static <T> Option<T> any(
		Option<T> op1, Option<T> op2, Option<T> op3, Option<T> op4,
		Option<T> op5, Option<T> op6, Option<T> op7, Option<T> op8
	) {
		return op1.or(op2).or(op3).or(op4).or(op5).or(op6).or(op7).or(op8);
	}

	/**
	 * Find first present option among ones passed as parameters.
	 *
	 * @return first present option or empty option if all input options are empty.
	 */
	static <T> Option<T> any(
		Option<T> op1, Option<T> op2, Option<T> op3, Option<T> op4, Option<T> op5,
		Option<T> op6, Option<T> op7, Option<T> op8, Option<T> op9
	) {
		return op1.or(op2).or(op3).or(op4).or(op5).or(op6).or(op7).or(op8).or(op9);
	}

	/**
	 * Transform option into option of tuple. The result is empty if input option is empty. Otherwise resulting instance
	 * contains tuple with input option value.
	 *
	 * @return {@link Mapper1} prepared for further transformation.
	 */
	static <T1> Mapper1<T1> all(Option<T1> op1) {
		return () -> op1.flatMap(v1 -> option(tuple(v1)));
	}

	/**
	 * Transform options into option of tuple of values. The result is empty if any input option is empty.
	 * Otherwise resulting instance contains tuple with values from input options.
	 *
	 * @return {@link Mapper2} prepared for further transformation.
	 */
	static <T1, T2> Mapper2<T1, T2> all(Option<T1> op1, Option<T2> op2) {
		return () -> op1.flatMap(v1 -> op2.flatMap(v2 -> option(tuple(v1, v2))));
	}

	/**
	 * Transform options into option of tuple of values. The result is empty if any input option is empty.
	 * Otherwise resulting instance contains tuple with values from input options.
	 *
	 * @return {@link Mapper3} prepared for further transformation.
	 */
	static <T1, T2, T3> Mapper3<T1, T2, T3> all(Option<T1> op1, Option<T2> op2, Option<T3> op3) {
		return () -> op1.flatMap(v1 -> op2.flatMap(v2 -> op3.flatMap(v3 -> option(tuple(v1, v2, v3)))));
	}

	/**
	 * Transform options into option of tuple of values. The result is empty if any input option is empty.
	 * Otherwise resulting instance contains tuple with values from input options.
	 *
	 * @return {@link Mapper4} prepared for further transformation.
	 */
	static <T1, T2, T3, T4> Mapper4<T1, T2, T3, T4> all(
		Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4
	) {
		return () -> op1.flatMap(
			v1 -> op2.flatMap(
				v2 -> op3.flatMap(
					v3 -> op4.flatMap(
						v4 -> Option.option(tuple(v1, v2, v3, v4))))));
	}

	/**
	 * Transform options into option of tuple of values. The result is empty if any input option is empty.
	 * Otherwise resulting instance contains tuple with values from input options.
	 *
	 * @return {@link Mapper5} prepared for further transformation.
	 */
	static <T1, T2, T3, T4, T5> Mapper5<T1, T2, T3, T4, T5> all(
		Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4, Option<T5> op5
	) {
		return () -> op1.flatMap(
			v1 -> op2.flatMap(
				v2 -> op3.flatMap(
					v3 -> op4.flatMap(
						v4 -> op5.flatMap(
							v5 -> option(tuple(v1, v2, v3, v4, v5)))))));
	}

	/**
	 * Transform options into option of tuple of values. The result is empty if any input option is empty.
	 * Otherwise resulting instance contains tuple with values from input options.
	 *
	 * @return {@link Mapper6} prepared for further transformation.
	 */
	static <T1, T2, T3, T4, T5, T6> Mapper6<T1, T2, T3, T4, T5, T6> all(
		Option<T1> op1, Option<T2> op2, Option<T3> op3,
		Option<T4> op4, Option<T5> op5, Option<T6> op6
	) {
		return () -> op1.flatMap(
			v1 -> op2.flatMap(
				v2 -> op3.flatMap(
					v3 -> op4.flatMap(
						v4 -> op5.flatMap(
							v5 -> op6.flatMap(
								v6 -> option(tuple(v1, v2, v3, v4, v5, v6))))))));
	}

	/**
	 * Transform options into option of tuple of values. The result is empty if any input option is empty.
	 * Otherwise resulting instance contains tuple with values from input options.
	 *
	 * @return {@link Mapper7} prepared for further transformation.
	 */
	static <T1, T2, T3, T4, T5, T6, T7> Mapper7<T1, T2, T3, T4, T5, T6, T7> all(
		Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4,
		Option<T5> op5, Option<T6> op6, Option<T7> op7
	) {
		return () -> op1.flatMap(
			v1 -> op2.flatMap(
				v2 -> op3.flatMap(
					v3 -> op4.flatMap(
						v4 -> op5.flatMap(
							v5 -> op6.flatMap(
								v6 -> op7.flatMap(
									v7 -> option(tuple(v1, v2, v3, v4, v5, v6, v7)))))))));
	}

	/**
	 * Transform options into option of tuple of values. The result is empty if any input option is empty.
	 * Otherwise resulting instance contains tuple with values from input options.
	 *
	 * @return {@link Mapper8} prepared for further transformation.
	 */
	static <T1, T2, T3, T4, T5, T6, T7, T8> Mapper8<T1, T2, T3, T4, T5, T6, T7, T8> all(
		Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4,
		Option<T5> op5, Option<T6> op6, Option<T7> op7, Option<T8> op8
	) {
		return () -> op1.flatMap(
			v1 -> op2.flatMap(
				v2 -> op3.flatMap(
					v3 -> op4.flatMap(
						v4 -> op5.flatMap(
							v5 -> op6.flatMap(
								v6 -> op7.flatMap(
									v7 -> op8.flatMap(
										v8 -> option(tuple(v1, v2, v3, v4, v5, v6, v7, v8))))))))));
	}

	/**
	 * Transform options into option of tuple of values. The result is empty if any input option is empty.
	 * Otherwise resulting instance contains tuple with values from input options.
	 *
	 * @return {@link Mapper9} prepared for further transformation.
	 */
	static <T1, T2, T3, T4, T5, T6, T7, T8, T9> Mapper9<T1, T2, T3, T4, T5, T6, T7, T8, T9> all(
		Option<T1> op1, Option<T2> op2, Option<T3> op3, Option<T4> op4, Option<T5> op5,
		Option<T6> op6, Option<T7> op7, Option<T8> op8, Option<T9> op9
	) {
		return () -> op1.flatMap(
			v1 -> op2.flatMap(
				v2 -> op3.flatMap(
					v3 -> op4.flatMap(
						v4 -> op5.flatMap(
							v5 -> op6.flatMap(
								v6 -> op7.flatMap(
									v7 -> op8.flatMap(
										v8 -> op9.flatMap(
											v9 -> option(tuple(v1, v2, v3, v4, v5, v6, v7, v8, v9)))))))))));
	}

	/**
	 * Helper interface for convenient {@link Tuple1} transformation.
	 */
	interface Mapper1<T1> {
		Option<Tuple1<T1>> id();

		default <R> Option<R> map(FN1<R, T1> mapper) {
			return id().map(tuple -> tuple.map(mapper));
		}

		default <R> Option<R> flatMap(FN1<Option<R>, T1> mapper) {
			return id().flatMap(tuple -> tuple.map(mapper));
		}
	}

	/**
	 * Helper interface for convenient {@link Tuple2} transformation.
	 */
	interface Mapper2<T1, T2> {
		Option<Tuple2<T1, T2>> id();

		default <R> Option<R> map(FN2<R, T1, T2> mapper) {
			return id().map(tuple -> tuple.map(mapper));
		}

		default <R> Option<R> flatMap(FN2<Option<R>, T1, T2> mapper) {
			return id().flatMap(tuple -> tuple.map(mapper));
		}
	}

	/**
	 * Helper interface for convenient {@link Tuple3} transformation.
	 */
	interface Mapper3<T1, T2, T3> {
		Option<Tuple3<T1, T2, T3>> id();

		default <R> Option<R> map(FN3<R, T1, T2, T3> mapper) {
			return id().map(tuple -> tuple.map(mapper));
		}

		default <R> Option<R> flatMap(FN3<Option<R>, T1, T2, T3> mapper) {
			return id().flatMap(tuple -> tuple.map(mapper));
		}
	}

	/**
	 * Helper interface for convenient {@link Tuple4} transformation.
	 */
	interface Mapper4<T1, T2, T3, T4> {
		Option<Tuple4<T1, T2, T3, T4>> id();

		default <R> Option<R> map(FN4<R, T1, T2, T3, T4> mapper) {
			return id().map(tuple -> tuple.map(mapper));
		}

		default <R> Option<R> flatMap(FN4<Option<R>, T1, T2, T3, T4> mapper) {
			return id().flatMap(tuple -> tuple.map(mapper));
		}
	}

	/**
	 * Helper interface for convenient {@link Tuple5} transformation.
	 */
	interface Mapper5<T1, T2, T3, T4, T5> {
		Option<Tuple5<T1, T2, T3, T4, T5>> id();

		default <R> Option<R> map(FN5<R, T1, T2, T3, T4, T5> mapper) {
			return id().map(tuple -> tuple.map(mapper));
		}

		default <R> Option<R> flatMap(FN5<Option<R>, T1, T2, T3, T4, T5> mapper) {
			return id().flatMap(tuple -> tuple.map(mapper));
		}
	}

	/**
	 * Helper interface for convenient {@link Tuple6} transformation.
	 */
	interface Mapper6<T1, T2, T3, T4, T5, T6> {
		Option<Tuple6<T1, T2, T3, T4, T5, T6>> id();

		default <R> Option<R> map(FN6<R, T1, T2, T3, T4, T5, T6> mapper) {
			return id().map(tuple -> tuple.map(mapper));
		}

		default <R> Option<R> flatMap(FN6<Option<R>, T1, T2, T3, T4, T5, T6> mapper) {
			return id().flatMap(tuple -> tuple.map(mapper));
		}
	}

	/**
	 * Helper interface for convenient {@link Tuple7} transformation.
	 */
	interface Mapper7<T1, T2, T3, T4, T5, T6, T7> {
		Option<Tuple7<T1, T2, T3, T4, T5, T6, T7>> id();

		default <R> Option<R> map(FN7<R, T1, T2, T3, T4, T5, T6, T7> mapper) {
			return id().map(tuple -> tuple.map(mapper));
		}

		default <R> Option<R> flatMap(FN7<Option<R>, T1, T2, T3, T4, T5, T6, T7> mapper) {
			return id().flatMap(tuple -> tuple.map(mapper));
		}
	}

	/**
	 * Helper interface for convenient {@link Tuple8} transformation.
	 */
	interface Mapper8<T1, T2, T3, T4, T5, T6, T7, T8> {
		Option<Tuple8<T1, T2, T3, T4, T5, T6, T7, T8>> id();

		default <R> Option<R> map(FN8<R, T1, T2, T3, T4, T5, T6, T7, T8> mapper) {
			return id().map(tuple -> tuple.map(mapper));
		}

		default <R> Option<R> flatMap(FN8<Option<R>, T1, T2, T3, T4, T5, T6, T7, T8> mapper) {
			return id().flatMap(tuple -> tuple.map(mapper));
		}
	}

	/**
	 * Helper interface for convenient {@link Tuple9} transformation.
	 */
	interface Mapper9<T1, T2, T3, T4, T5, T6, T7, T8, T9> {
		Option<Tuple9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> id();

		default <R> Option<R> map(FN9<R, T1, T2, T3, T4, T5, T6, T7, T8, T9> mapper) {
			return id().map(tuple -> tuple.map(mapper));
		}

		default <R> Option<R> flatMap(FN9<Option<R>, T1, T2, T3, T4, T5, T6, T7, T8, T9> mapper) {
			return id().flatMap(tuple -> tuple.map(mapper));
		}
	}
}
